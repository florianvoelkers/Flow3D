<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.10"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::type Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.5</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>RTTR</span></a></li>
      <li><a href="pages.html"><span>Tutorial</span></a></li>
      <li><a href="pages.html"><span>Installation</span></a></li>
      <li><a href="pages.html"><span>License</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1type.html">type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classrttr_1_1type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classrttr_1_1type.html">type</a> class holds the type information for any arbitrary object.  
 <a href="classrttr_1_1type.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa51c17659f86333038379c23b03d2db0"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">type_id</a></td></tr>
<tr class="separator:aa51c17659f86333038379c23b03d2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74865ba400ab02d7f397ee7cf819df32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a74865ba400ab02d7f397ee7cf819df32">type</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other)</td></tr>
<tr class="memdesc:a74865ba400ab02d7f397ee7cf819df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a type to another one.  <a href="#a74865ba400ab02d7f397ee7cf819df32">More...</a><br /></td></tr>
<tr class="separator:a74865ba400ab02d7f397ee7cf819df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c54948eafb21fe494afd1057117f5c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a8c54948eafb21fe494afd1057117f5c1">create</a> (std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args=std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;()) const </td></tr>
<tr class="memdesc:a8c54948eafb21fe494afd1057117f5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the current type, with the given arguments <code>args</code> for the constructor.  <a href="#a8c54948eafb21fe494afd1057117f5c1">More...</a><br /></td></tr>
<tr class="separator:a8c54948eafb21fe494afd1057117f5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73823b1d1e4158329a341650aa151ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a73823b1d1e4158329a341650aa151ef5">destroy</a> (<a class="el" href="classrttr_1_1variant.html">variant</a> &amp;obj) const </td></tr>
<tr class="memdesc:a73823b1d1e4158329a341650aa151ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given object <code>obj</code>.  <a href="#a73823b1d1e4158329a341650aa151ef5">More...</a><br /></td></tr>
<tr class="separator:a73823b1d1e4158329a341650aa151ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a9264500d8edd2715c020be9a0f23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1constructor.html">constructor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae0a9264500d8edd2715c020be9a0f23f">get_constructor</a> (const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;params=std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;()) const </td></tr>
<tr class="memdesc:ae0a9264500d8edd2715c020be9a0f23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a public constructor whose parameters match the types in the specified list.  <a href="#ae0a9264500d8edd2715c020be9a0f23f">More...</a><br /></td></tr>
<tr class="separator:ae0a9264500d8edd2715c020be9a0f23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23925b0980e4012786d9a45fe3e0ef8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrttr_1_1constructor.html">constructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ab23925b0980e4012786d9a45fe3e0ef8">get_constructors</a> () const </td></tr>
<tr class="memdesc:ab23925b0980e4012786d9a45fe3e0ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all registered constructors for this type; the order is unspecified.  <a href="#ab23925b0980e4012786d9a45fe3e0ef8">More...</a><br /></td></tr>
<tr class="separator:ab23925b0980e4012786d9a45fe3e0ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917eeccdd8fbab4b9710b61d56af26b2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a917eeccdd8fbab4b9710b61d56af26b2">get_derived_classes</a> () const </td></tr>
<tr class="memdesc:a917eeccdd8fbab4b9710b61d56af26b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all derived classes of this type.  <a href="#a917eeccdd8fbab4b9710b61d56af26b2">More...</a><br /></td></tr>
<tr class="separator:a917eeccdd8fbab4b9710b61d56af26b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2402c4753ca103c9a80f918a377fb15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1destructor.html">destructor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ab2402c4753ca103c9a80f918a377fb15">get_destructor</a> () const </td></tr>
<tr class="memdesc:ab2402c4753ca103c9a80f918a377fb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding destructor for this type.  <a href="#ab2402c4753ca103c9a80f918a377fb15">More...</a><br /></td></tr>
<tr class="separator:ab2402c4753ca103c9a80f918a377fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace0722fb1d24aee882d6eb2cbda1d4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1enumeration.html">enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aace0722fb1d24aee882d6eb2cbda1d4b">get_enumeration</a> () const </td></tr>
<tr class="memdesc:aace0722fb1d24aee882d6eb2cbda1d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator if this type is an enum type; otherwise the returned value is <a class="el" href="classrttr_1_1enumeration.html#a1fd018ee249ea1e431dc85aa8d391749">not valid</a>.  <a href="#aace0722fb1d24aee882d6eb2cbda1d4b">More...</a><br /></td></tr>
<tr class="separator:aace0722fb1d24aee882d6eb2cbda1d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7e4653e333b5dfdeaa9b9383d954b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">type_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#abb7e4653e333b5dfdeaa9b9383d954b1">get_id</a> () const </td></tr>
<tr class="memdesc:abb7e4653e333b5dfdeaa9b9383d954b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the id of this type.  <a href="#abb7e4653e333b5dfdeaa9b9383d954b1">More...</a><br /></td></tr>
<tr class="separator:abb7e4653e333b5dfdeaa9b9383d954b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825f853dc03724ff3257a194f05070d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a825f853dc03724ff3257a194f05070d5">get_metadata</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;key) const </td></tr>
<tr class="memdesc:a825f853dc03724ff3257a194f05070d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta data for the given key <code>key</code>.  <a href="#a825f853dc03724ff3257a194f05070d5">More...</a><br /></td></tr>
<tr class="separator:a825f853dc03724ff3257a194f05070d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175fdface61f5d9f04c03ffa06608237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a175fdface61f5d9f04c03ffa06608237">get_method</a> (const char *name) const </td></tr>
<tr class="memdesc:a175fdface61f5d9f04c03ffa06608237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a method with the name <code>name</code>.  <a href="#a175fdface61f5d9f04c03ffa06608237">More...</a><br /></td></tr>
<tr class="separator:a175fdface61f5d9f04c03ffa06608237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32baf74274a3bc95828843bd52e7d854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a32baf74274a3bc95828843bd52e7d854">get_method</a> (const char *name, const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;params) const </td></tr>
<tr class="memdesc:a32baf74274a3bc95828843bd52e7d854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a method with the name <code>name</code> which match the given parameter list <code>params</code>.  <a href="#a32baf74274a3bc95828843bd52e7d854">More...</a><br /></td></tr>
<tr class="separator:a32baf74274a3bc95828843bd52e7d854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf9a2bdf56f37bd5ac31e054a1e20c5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afcf9a2bdf56f37bd5ac31e054a1e20c5">get_methods</a> () const </td></tr>
<tr class="memdesc:afcf9a2bdf56f37bd5ac31e054a1e20c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all registered methods for this type and all its base classes.  <a href="#afcf9a2bdf56f37bd5ac31e054a1e20c5">More...</a><br /></td></tr>
<tr class="separator:afcf9a2bdf56f37bd5ac31e054a1e20c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260f13a9434bf60c5dd3fa239f5890b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a260f13a9434bf60c5dd3fa239f5890b5">get_name</a> () const </td></tr>
<tr class="memdesc:a260f13a9434bf60c5dd3fa239f5890b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique and human-readable name of the type.  <a href="#a260f13a9434bf60c5dd3fa239f5890b5">More...</a><br /></td></tr>
<tr class="separator:a260f13a9434bf60c5dd3fa239f5890b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d1e7359ac93bdf53b2e20adf827d3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ab5d1e7359ac93bdf53b2e20adf827d3e">get_properties</a> () const </td></tr>
<tr class="memdesc:ab5d1e7359ac93bdf53b2e20adf827d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all registered properties for this type and all its base classes.  <a href="#ab5d1e7359ac93bdf53b2e20adf827d3e">More...</a><br /></td></tr>
<tr class="separator:ab5d1e7359ac93bdf53b2e20adf827d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5947a5453ddfd7288445d1035d708b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1property.html">property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa5947a5453ddfd7288445d1035d708b8">get_property</a> (const char *name) const </td></tr>
<tr class="memdesc:aa5947a5453ddfd7288445d1035d708b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a property with the name <code>name</code>.  <a href="#aa5947a5453ddfd7288445d1035d708b8">More...</a><br /></td></tr>
<tr class="separator:aa5947a5453ddfd7288445d1035d708b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a46f8ec98eb9ec928bc18591c6b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afa8a46f8ec98eb9ec928bc18591c6b9e">get_property_value</a> (const char *name, <a class="el" href="classrttr_1_1instance.html">instance</a> obj) const </td></tr>
<tr class="memdesc:afa8a46f8ec98eb9ec928bc18591c6b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property value of property named <code>name</code> from the instance <code>obj</code>.  <a href="#afa8a46f8ec98eb9ec928bc18591c6b9e">More...</a><br /></td></tr>
<tr class="separator:afa8a46f8ec98eb9ec928bc18591c6b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc5cad32ed059496b31c9f764b4cb0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aefc5cad32ed059496b31c9f764b4cb0d">get_raw_type</a> () const </td></tr>
<tr class="memdesc:aefc5cad32ed059496b31c9f764b4cb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object which represent the raw type.  <a href="#aefc5cad32ed059496b31c9f764b4cb0d">More...</a><br /></td></tr>
<tr class="separator:aefc5cad32ed059496b31c9f764b4cb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401c0dd60d4cc484f6f80cd44e529979"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a401c0dd60d4cc484f6f80cd44e529979">get_sizeof</a> () const </td></tr>
<tr class="memdesc:a401c0dd60d4cc484f6f80cd44e529979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the object representation of the current type (i.e.  <a href="#a401c0dd60d4cc484f6f80cd44e529979">More...</a><br /></td></tr>
<tr class="separator:a401c0dd60d4cc484f6f80cd44e529979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0935035914ebe4ed4e37f6b7a6846cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0935035914ebe4ed4e37f6b7a6846cc7">get_wrapped_type</a> () const </td></tr>
<tr class="memdesc:a0935035914ebe4ed4e37f6b7a6846cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object which represent the wrapped type.  <a href="#a0935035914ebe4ed4e37f6b7a6846cc7">More...</a><br /></td></tr>
<tr class="separator:a0935035914ebe4ed4e37f6b7a6846cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8df07012568973ca0a4c005a5af5dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae8df07012568973ca0a4c005a5af5dba">invoke</a> (const char *name, <a class="el" href="classrttr_1_1instance.html">instance</a> obj, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args) const </td></tr>
<tr class="memdesc:ae8df07012568973ca0a4c005a5af5dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>.  <a href="#ae8df07012568973ca0a4c005a5af5dba">More...</a><br /></td></tr>
<tr class="separator:ae8df07012568973ca0a4c005a5af5dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac02f948da52aab53c0b52d81685881e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aac02f948da52aab53c0b52d81685881e">is_arithmetic</a> () const </td></tr>
<tr class="memdesc:aac02f948da52aab53c0b52d81685881e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an arithmetic type.  <a href="#aac02f948da52aab53c0b52d81685881e">More...</a><br /></td></tr>
<tr class="separator:aac02f948da52aab53c0b52d81685881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42461eee870c91e6b183610f2f24f700"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a42461eee870c91e6b183610f2f24f700">is_array</a> () const </td></tr>
<tr class="memdesc:a42461eee870c91e6b183610f2f24f700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an array.  <a href="#a42461eee870c91e6b183610f2f24f700">More...</a><br /></td></tr>
<tr class="separator:a42461eee870c91e6b183610f2f24f700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f0af6a51c3d6096ea445288caacfce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a30f0af6a51c3d6096ea445288caacfce">is_class</a> () const </td></tr>
<tr class="memdesc:a30f0af6a51c3d6096ea445288caacfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type is class; that is not an atomic type or a method.  <a href="#a30f0af6a51c3d6096ea445288caacfce">More...</a><br /></td></tr>
<tr class="separator:a30f0af6a51c3d6096ea445288caacfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4142afe939a1c28047b3aa7eb61ed0da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4142afe939a1c28047b3aa7eb61ed0da">is_derived_from</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const </td></tr>
<tr class="memdesc:a4142afe939a1c28047b3aa7eb61ed0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is derived from the given type <code>other</code>, otherwise false.  <a href="#a4142afe939a1c28047b3aa7eb61ed0da">More...</a><br /></td></tr>
<tr class="separator:a4142afe939a1c28047b3aa7eb61ed0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766405230daf54ea17c261cf1a5a31b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a766405230daf54ea17c261cf1a5a31b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a766405230daf54ea17c261cf1a5a31b3">is_derived_from</a> () const </td></tr>
<tr class="memdesc:a766405230daf54ea17c261cf1a5a31b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is derived from the given type <em>T</em>, otherwise false.  <a href="#a766405230daf54ea17c261cf1a5a31b3">More...</a><br /></td></tr>
<tr class="separator:a766405230daf54ea17c261cf1a5a31b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35926cc4f93039e967eadf36107f3855"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a35926cc4f93039e967eadf36107f3855">is_enumeration</a> () const </td></tr>
<tr class="memdesc:a35926cc4f93039e967eadf36107f3855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents an enumeration.  <a href="#a35926cc4f93039e967eadf36107f3855">More...</a><br /></td></tr>
<tr class="separator:a35926cc4f93039e967eadf36107f3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d52aa9d36a4ca87426ba8f0a767f67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a34d52aa9d36a4ca87426ba8f0a767f67">is_function_pointer</a> () const </td></tr>
<tr class="memdesc:a34d52aa9d36a4ca87426ba8f0a767f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a function e.g.  <a href="#a34d52aa9d36a4ca87426ba8f0a767f67">More...</a><br /></td></tr>
<tr class="separator:a34d52aa9d36a4ca87426ba8f0a767f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb157054ff6cc035362ddb48fce72497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afb157054ff6cc035362ddb48fce72497">is_member_function_pointer</a> () const </td></tr>
<tr class="memdesc:afb157054ff6cc035362ddb48fce72497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a member function.  <a href="#afb157054ff6cc035362ddb48fce72497">More...</a><br /></td></tr>
<tr class="separator:afb157054ff6cc035362ddb48fce72497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551a5b2e5f019476812608abd6af777d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a551a5b2e5f019476812608abd6af777d">is_member_object_pointer</a> () const </td></tr>
<tr class="memdesc:a551a5b2e5f019476812608abd6af777d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer to a member object.  <a href="#a551a5b2e5f019476812608abd6af777d">More...</a><br /></td></tr>
<tr class="separator:a551a5b2e5f019476812608abd6af777d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31c9ee6ca22898a8853dfde804a3bc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ae31c9ee6ca22898a8853dfde804a3bc6">is_pointer</a> () const </td></tr>
<tr class="memdesc:ae31c9ee6ca22898a8853dfde804a3bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a pointer.  <a href="#ae31c9ee6ca22898a8853dfde804a3bc6">More...</a><br /></td></tr>
<tr class="separator:ae31c9ee6ca22898a8853dfde804a3bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ca3f29b201c49b744ab9f6b887471e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a26ca3f29b201c49b744ab9f6b887471e">is_valid</a> () const </td></tr>
<tr class="memdesc:a26ca3f29b201c49b744ab9f6b887471e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this type is valid, that means the type holds valid data to a type.  <a href="#a26ca3f29b201c49b744ab9f6b887471e">More...</a><br /></td></tr>
<tr class="separator:a26ca3f29b201c49b744ab9f6b887471e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395600fecd4a773b3ae1064b3391d556"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a395600fecd4a773b3ae1064b3391d556">is_wrapper</a> () const </td></tr>
<tr class="memdesc:a395600fecd4a773b3ae1064b3391d556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the given type represents a wrapper type.  <a href="#a395600fecd4a773b3ae1064b3391d556">More...</a><br /></td></tr>
<tr class="separator:a395600fecd4a773b3ae1064b3391d556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036ca04498a80781f524d94910922d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a7036ca04498a80781f524d94910922d0">operator bool</a> () const </td></tr>
<tr class="memdesc:a7036ca04498a80781f524d94910922d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to check if this <a class="el" href="classrttr_1_1type.html">type</a> is valid or not.  <a href="#a7036ca04498a80781f524d94910922d0">More...</a><br /></td></tr>
<tr class="separator:a7036ca04498a80781f524d94910922d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988c18304bc7e14a4e6ccff4b3ee764d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a988c18304bc7e14a4e6ccff4b3ee764d">operator!=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const </td></tr>
<tr class="memdesc:a988c18304bc7e14a4e6ccff4b3ee764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this type with the <em>other</em> type and returns true if both describe different types, otherwise returns false.  <a href="#a988c18304bc7e14a4e6ccff4b3ee764d">More...</a><br /></td></tr>
<tr class="separator:a988c18304bc7e14a4e6ccff4b3ee764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f449e42eba11f2201ed2c12ba2be8e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4f449e42eba11f2201ed2c12ba2be8e8">operator&lt;</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const </td></tr>
<tr class="memdesc:a4f449e42eba11f2201ed2c12ba2be8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#a4f449e42eba11f2201ed2c12ba2be8e8">More...</a><br /></td></tr>
<tr class="separator:a4f449e42eba11f2201ed2c12ba2be8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39064267f8bc64695053e70fc5742ed8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a39064267f8bc64695053e70fc5742ed8">operator&lt;=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const </td></tr>
<tr class="memdesc:a39064267f8bc64695053e70fc5742ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#a39064267f8bc64695053e70fc5742ed8">More...</a><br /></td></tr>
<tr class="separator:a39064267f8bc64695053e70fc5742ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef57d6c4fe2940fc8f5218d27dab8ee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aef57d6c4fe2940fc8f5218d27dab8ee6">operator=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other)</td></tr>
<tr class="memdesc:aef57d6c4fe2940fc8f5218d27dab8ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a type to another one.  <a href="#aef57d6c4fe2940fc8f5218d27dab8ee6">More...</a><br /></td></tr>
<tr class="separator:aef57d6c4fe2940fc8f5218d27dab8ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22a16e1984a7b7874bfe588c68c1db1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#af22a16e1984a7b7874bfe588c68c1db1">operator==</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const </td></tr>
<tr class="memdesc:af22a16e1984a7b7874bfe588c68c1db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this type with the <em>other</em> type and returns true if both describe the same type, otherwise returns false.  <a href="#af22a16e1984a7b7874bfe588c68c1db1">More...</a><br /></td></tr>
<tr class="separator:af22a16e1984a7b7874bfe588c68c1db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615b3b385f10580ba12250ec9e407e06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a615b3b385f10580ba12250ec9e407e06">operator&gt;</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const </td></tr>
<tr class="memdesc:a615b3b385f10580ba12250ec9e407e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#a615b3b385f10580ba12250ec9e407e06">More...</a><br /></td></tr>
<tr class="separator:a615b3b385f10580ba12250ec9e407e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c60996f2aa6260d9eba48b8a6834039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0c60996f2aa6260d9eba48b8a6834039">operator&gt;=</a> (const <a class="el" href="classrttr_1_1type.html">type</a> &amp;other) const </td></tr>
<tr class="memdesc:a0c60996f2aa6260d9eba48b8a6834039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for sorting the type data according to some internal criterion.  <a href="#a0c60996f2aa6260d9eba48b8a6834039">More...</a><br /></td></tr>
<tr class="separator:a0c60996f2aa6260d9eba48b8a6834039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84005c7450f740c8b191ffdd7ea469db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a84005c7450f740c8b191ffdd7ea469db">set_property_value</a> (const char *name, <a class="el" href="classrttr_1_1instance.html">instance</a> obj, <a class="el" href="classrttr_1_1argument.html">argument</a> arg) const </td></tr>
<tr class="memdesc:a84005c7450f740c8b191ffdd7ea469db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the given value <code>arg</code> to a property named <code>name</code> to the instance <code>obj</code>.  <a href="#a84005c7450f740c8b191ffdd7ea469db">More...</a><br /></td></tr>
<tr class="separator:a84005c7450f740c8b191ffdd7ea469db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afe97727ddb45e58a862e994f194b977b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe97727ddb45e58a862e994f194b977b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">get</a> ()</td></tr>
<tr class="memdesc:afe97727ddb45e58a862e994f194b977b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object for the given template type <em>T</em>.  <a href="#afe97727ddb45e58a862e994f194b977b">More...</a><br /></td></tr>
<tr class="separator:afe97727ddb45e58a862e994f194b977b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2951743e8fd51ccfd28e1bda20d2053c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2951743e8fd51ccfd28e1bda20d2053c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a2951743e8fd51ccfd28e1bda20d2053c">get</a> (T &amp;&amp;object)</td></tr>
<tr class="memdesc:a2951743e8fd51ccfd28e1bda20d2053c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type object for the given instance <em>object</em>.  <a href="#a2951743e8fd51ccfd28e1bda20d2053c">More...</a><br /></td></tr>
<tr class="separator:a2951743e8fd51ccfd28e1bda20d2053c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2252762fa17e4df5151ab122b622c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a7c2252762fa17e4df5151ab122b622c2">get_by_name</a> (const char *name)</td></tr>
<tr class="memdesc:a7c2252762fa17e4df5151ab122b622c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type object with the given name <code>name</code>.  <a href="#a7c2252762fa17e4df5151ab122b622c2">More...</a><br /></td></tr>
<tr class="separator:a7c2252762fa17e4df5151ab122b622c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd45f57e1c620dbb07aa12f9057caa7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#acd45f57e1c620dbb07aa12f9057caa7f">get_global_method</a> (const char *name)</td></tr>
<tr class="memdesc:acd45f57e1c620dbb07aa12f9057caa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global method with the name <code>name</code>.  <a href="#acd45f57e1c620dbb07aa12f9057caa7f">More...</a><br /></td></tr>
<tr class="separator:acd45f57e1c620dbb07aa12f9057caa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19b061c7c2126130fdbf7a451730a82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1method.html">method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#aa19b061c7c2126130fdbf7a451730a82">get_global_method</a> (const char *name, const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;params)</td></tr>
<tr class="memdesc:aa19b061c7c2126130fdbf7a451730a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global method with the name <code>name</code> which match the given parameter list <code>params</code>.  <a href="#aa19b061c7c2126130fdbf7a451730a82">More...</a><br /></td></tr>
<tr class="separator:aa19b061c7c2126130fdbf7a451730a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd97ae3d750d4433b679b13a04842bd5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classrttr_1_1method.html">method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#afd97ae3d750d4433b679b13a04842bd5">get_global_methods</a> ()</td></tr>
<tr class="memdesc:afd97ae3d750d4433b679b13a04842bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all registered global methods.  <a href="#afd97ae3d750d4433b679b13a04842bd5">More...</a><br /></td></tr>
<tr class="separator:afd97ae3d750d4433b679b13a04842bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8258dd74855a0a54cfc83ffbbdd6d63"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classrttr_1_1property.html">property</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#ab8258dd74855a0a54cfc83ffbbdd6d63">get_global_properties</a> ()</td></tr>
<tr class="memdesc:ab8258dd74855a0a54cfc83ffbbdd6d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all registered global properties.  <a href="#ab8258dd74855a0a54cfc83ffbbdd6d63">More...</a><br /></td></tr>
<tr class="separator:ab8258dd74855a0a54cfc83ffbbdd6d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae36bf9d997fb8153cdd718e2625f9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1property.html">property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a3ae36bf9d997fb8153cdd718e2625f9d">get_global_property</a> (const char *name)</td></tr>
<tr class="memdesc:a3ae36bf9d997fb8153cdd718e2625f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global property with the name <code>name</code>.  <a href="#a3ae36bf9d997fb8153cdd718e2625f9d">More...</a><br /></td></tr>
<tr class="separator:a3ae36bf9d997fb8153cdd718e2625f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480c12eb9ef23f62b848afce39cd9e17"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a480c12eb9ef23f62b848afce39cd9e17">get_property_value</a> (const char *name)</td></tr>
<tr class="memdesc:a480c12eb9ef23f62b848afce39cd9e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property value of property named <code>name</code>.  <a href="#a480c12eb9ef23f62b848afce39cd9e17">More...</a><br /></td></tr>
<tr class="separator:a480c12eb9ef23f62b848afce39cd9e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5d699f5e6d4a860f83b5a3f2745ddc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#adf5d699f5e6d4a860f83b5a3f2745ddc">get_types</a> ()</td></tr>
<tr class="memdesc:adf5d699f5e6d4a860f83b5a3f2745ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all registered type objects.  <a href="#adf5d699f5e6d4a860f83b5a3f2745ddc">More...</a><br /></td></tr>
<tr class="separator:adf5d699f5e6d4a860f83b5a3f2745ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784a38776994799b5352754443781f99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a784a38776994799b5352754443781f99">invoke</a> (const char *name, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args)</td></tr>
<tr class="memdesc:a784a38776994799b5352754443781f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a global method named <code>name</code> with the specified argument <code>args</code>.  <a href="#a784a38776994799b5352754443781f99">More...</a><br /></td></tr>
<tr class="separator:a784a38776994799b5352754443781f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4912d4dac773276a6142a70a40ab0543"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4912d4dac773276a6142a70a40ab0543"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a4912d4dac773276a6142a70a40ab0543">register_comparators</a> ()</td></tr>
<tr class="memdesc:a4912d4dac773276a6142a70a40ab0543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register comparison operators for template type <code>T</code>.  <a href="#a4912d4dac773276a6142a70a40ab0543">More...</a><br /></td></tr>
<tr class="separator:a4912d4dac773276a6142a70a40ab0543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f5f2ea31cc79846a829aa5737680f0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a81f5f2ea31cc79846a829aa5737680f0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">register_converter_func</a> (F func)</td></tr>
<tr class="memdesc:a81f5f2ea31cc79846a829aa5737680f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a converter func <code>F</code>, which will be used internally by the <a class="el" href="classrttr_1_1variant.html">variant</a> class to convert between types.  <a href="#a81f5f2ea31cc79846a829aa5737680f0">More...</a><br /></td></tr>
<tr class="separator:a81f5f2ea31cc79846a829aa5737680f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec6614b4bfadc10d05f6ac5a1f62fe4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a0ec6614b4bfadc10d05f6ac5a1f62fe4">set_property_value</a> (const char *name, <a class="el" href="classrttr_1_1argument.html">argument</a> arg)</td></tr>
<tr class="memdesc:a0ec6614b4bfadc10d05f6ac5a1f62fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the given value <code>arg</code> to a property named <code>name</code>.  <a href="#a0ec6614b4bfadc10d05f6ac5a1f62fe4">More...</a><br /></td></tr>
<tr class="separator:a0ec6614b4bfadc10d05f6ac5a1f62fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a74abb6f591469f3735a1086764f3f8af"><td class="memTemplParams" colspan="2">template&lt;typename Target_Type , typename Source_Type &gt; </td></tr>
<tr class="memitem:a74abb6f591469f3735a1086764f3f8af"><td class="memTemplItemLeft" align="right" valign="top">Target_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrttr_1_1type.html#a74abb6f591469f3735a1086764f3f8af">rttr_cast</a> (Source_Type object)</td></tr>
<tr class="memdesc:a74abb6f591469f3735a1086764f3f8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the given <code>object</code> of type <code>Source_Type</code> to an object of type <code>Target_Type</code>.  <a href="#a74abb6f591469f3735a1086764f3f8af">More...</a><br /></td></tr>
<tr class="separator:a74abb6f591469f3735a1086764f3f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classrttr_1_1type.html">type</a> class holds the type information for any arbitrary object. </p>
<p>Every class or primitive data type can have an unique type object. With the help of this object you can compare unknown types for equality at runtime or introspect the type for its <a class="el" href="classrttr_1_1property.html">properties</a>, <a class="el" href="classrttr_1_1method.html">methods</a>, <a class="el" href="classrttr_1_1enumeration.html">enumerations</a>, <a class="el" href="classrttr_1_1constructor.html">constructors</a> and <a class="el" href="classrttr_1_1destructor.html">destructor</a>.</p>
<h2>Retrieve type </h2>
<p>A type object <b>cannot</b> be created. It is only possible to retrieve a type object via three static template member functions:</p>
<h3><a class="el" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b" title="Returns a type object for the given template type T. ">type::get&lt;T&gt;()</a></h3>
<p>This function just expects one template argument. Use it to check against a known type.</p>
<div class="fragment"><div class="line">type::get&lt;int&gt;() == type::get&lt;int&gt;();  <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;int&gt;() == type::get&lt;bool&gt;(); <span class="comment">// yields to false</span></div>
</div><!-- fragment --><h3><a class="el" href="classrttr_1_1type.html#a7c2252762fa17e4df5151ab122b622c2" title="Returns the type object with the given name name. ">type::get_by_name(const char*)</a></h3>
<p>This function just expects the name of the type. This is useful when you know only the name of the type and cannot include the type itself into the source code.</p>
<div class="fragment"><div class="line"><a class="code" href="classrttr_1_1type.html#a7c2252762fa17e4df5151ab122b622c2">type::get_by_name</a>(<span class="stringliteral">&quot;int&quot;</span>)  == type::get&lt;int&gt;(); <span class="comment">// yields to true</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a7c2252762fa17e4df5151ab122b622c2">type::get_by_name</a>(<span class="stringliteral">&quot;bool&quot;</span>) == type::get&lt;int&gt;(); <span class="comment">// yields to false</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a7c2252762fa17e4df5151ab122b622c2">type::get_by_name</a>(<span class="stringliteral">&quot;MyNameSpace::MyStruct&quot;</span>) == type::get&lt;MyNameSpace::MyStruct&gt;();  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Before using the function <a class="el" href="classrttr_1_1type.html#a7c2252762fa17e4df5151ab122b622c2">type::get_by_name()</a>, you have to use one time the function via <a class="el" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get&lt;T&gt;()</a>, otherwise the type is not registered in the type system.</dd></dl>
<h3><a class="el" href="classrttr_1_1type.html#a2951743e8fd51ccfd28e1bda20d2053c" title="Returns a type object for the given instance object. ">type::get&lt;T&gt;(T&amp;&amp; obj)</a></h3>
<p>This function takes a universal reference and returns from every given object the corresponding type object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> int_obj;</div>
<div class="line"><span class="keywordtype">int</span>* int_obj_ptr = &amp;int_obj;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* c_int_obj_ptr = int_obj_ptr;</div>
<div class="line"></div>
<div class="line">type::get&lt;int&gt;()         == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(int_obj);        <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;int*&gt;()        == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(int_obj_ptr);    <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;const int*&gt;()  == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(c_int_obj_ptr);  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><p>When this function is called for a glvalue expression whose type is a polymorphic class type, then the result refers to a <a class="el" href="classrttr_1_1type.html">type</a> object representing the type of the most derived object.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Base { <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>() };</div>
<div class="line"><span class="keyword">struct </span>Derived : Base { <a class="code" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a>(Base) };</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">Derived d;</div>
<div class="line">Base&amp; base = d;</div>
<div class="line">type::get&lt;Derived&gt;()   == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(base);      <span class="comment">// yields to true</span></div>
<div class="line">type::get&lt;Base&gt;()      == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(base);      <span class="comment">// yields to false</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// remark, when called with pointers:</span></div>
<div class="line">Base* base_ptr = &amp;d;</div>
<div class="line">type::get&lt;Derived&gt;()   == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(base_ptr);  <span class="comment">// yields to false</span></div>
<div class="line">type::get&lt;Base*&gt;()     == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(base_ptr);  <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>If the type of the expression is a cv-qualified type, the result of the <a class="el" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b" title="Returns a type object for the given template type T. ">rttr::type::get</a> expression refers to a <a class="el" href="classrttr_1_1type.html" title="The type class holds the type information for any arbitrary object. ">rttr::type</a> object representing the cv-unqualified type.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">class </span>D { ... };</div>
<div class="line">D d1;</div>
<div class="line"><span class="keyword">const</span> D d2;</div>
<div class="line"><a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(d1)  == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&gt;();  <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == <a class="code" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b">type::get</a>(d2);         <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D&amp;&gt;(); <span class="comment">// yields true</span></div>
<div class="line">type::get&lt;D&gt;() == type::get&lt;const D*&gt;(); <span class="comment">// yields false</span></div>
</div><!-- fragment --><p> Any <code>top level</code> cv-qualifier of the given type <code>T</code> will be removed.</p>
<h2>Copying and Assignment </h2>
<p>A <a class="el" href="classrttr_1_1type.html">type</a> object is lightweight and can be copied by value. However, each copy will refer to the same underlying type. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa51c17659f86333038379c23b03d2db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">rttr::type::type_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a74865ba400ab02d7f397ee7cf819df32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rttr::type::type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a type to another one. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8c54948eafb21fe494afd1057117f5c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em> = <code>std::vector&lt;&#160;<a class="el" href="classrttr_1_1argument.html">argument</a>&#160;&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the current type, with the given arguments <code>args</code> for the constructor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the argument types does not match the parameter list of the constructor then the he will not be invoked. Constructors with registered <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> will be honored.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of the given type. </dd></dl>

</div>
</div>
<a class="anchor" id="a73823b1d1e4158329a341650aa151ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rttr::type::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given object <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the <code>obj</code> could be destroyed the given <code>obj</code> is invalid after calling this method; Otherwise it is still valid. </dd></dl>

</div>
</div>
<a class="anchor" id="afe97727ddb45e58a862e994f194b977b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object for the given template type <em>T</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>type for the template type <em>T</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2951743e8fd51ccfd28e1bda20d2053c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a type object for the given instance <em>object</em>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If the type of the expression is a cv-qualified type, the result of the <a class="el" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b" title="Returns a type object for the given template type T. ">type::get()</a> expression refers to a type object representing the cv-unqualified type. When <a class="el" href="classrttr_1_1type.html#afe97727ddb45e58a862e994f194b977b" title="Returns a type object for the given template type T. ">type::get()</a> is applied to a glvalue expression whose type is a polymorphic class type, the result refers to a type object representing the type of the most derived object.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>type for an <em>object</em> of type <em>T</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c2252762fa17e4df5151ab122b622c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type object with the given name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The search for the type is case sensitive. White spaces will be ignored. The name of the type corresponds to the name which was used during <a class="el" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a>. Only after the registration process was executed, then the type can be retrieved with this function. Otherwise and invalid type will be returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrttr_1_1type.html">type</a> object with the name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0a9264500d8edd2715c020be9a0f23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1constructor.html">constructor</a> rttr::type::get_constructor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>std::vector&lt;&#160;<a class="el" href="classrttr_1_1type.html">type</a>&#160;&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a public constructor whose parameters match the types in the specified list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no parameter list is given, it will be searched for the default constructor.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A valid constructor will be returned when the parameter matches the registered constructor; otherwise an invalid constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="ab23925b0980e4012786d9a45fe3e0ef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrttr_1_1constructor.html">constructor</a>&gt; rttr::type::get_constructors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all registered constructors for this type; the order is unspecified. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of all registered constructors. </dd></dl>

</div>
</div>
<a class="anchor" id="a917eeccdd8fbab4b9710b61d56af26b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrttr_1_1type.html">type</a>&gt; rttr::type::get_derived_classes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all derived classes of this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>. The order of this list depends on the declaration order of classes inside RTTR_ENABLE. E.g. <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59" title="This macro is necessary in order to retrieve type information about the inheritance graph of a class...">RTTR_ENABLE(A1, A2)</a> =&gt; A1 will be for A2 in the list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A list of type objects. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2402c4753ca103c9a80f918a377fb15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1destructor.html">destructor</a> rttr::type::get_destructor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the corresponding destructor for this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there is no constructor registered for this type, then also the destructor is not available. A destructor will always been automatically registered.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the destructor for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="aace0722fb1d24aee882d6eb2cbda1d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1enumeration.html">enumeration</a> rttr::type::get_enumeration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator if this type is an enum type; otherwise the returned value is <a class="el" href="classrttr_1_1enumeration.html#a1fd018ee249ea1e431dc85aa8d391749">not valid</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1type.html#a35926cc4f93039e967eadf36107f3855" title="Returns true whether the given type represents an enumeration. ">is_enumeration()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A enumeration object. </dd></dl>

</div>
</div>
<a class="anchor" id="acd45f57e1c620dbb07aa12f9057caa7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_global_method </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global method with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code>, and invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa19b061c7c2126130fdbf7a451730a82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_global_method </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global method with the name <code>name</code> which match the given parameter list <code>params</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code> and matching parameter list <code>params</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code> and parameter signature <code>params</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afd97ae3d750d4433b679b13a04842bd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classrttr_1_1method.html">method</a>&gt; rttr::type::get_global_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all registered global methods. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the methods in the vector is undefined. Client code should <b>not</b> depend on the order in which methods are returned, because that order varies.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with methods. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8258dd74855a0a54cfc83ffbbdd6d63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classrttr_1_1property.html">property</a>&gt; rttr::type::get_global_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all registered global properties. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the properties in the vector is undefined. Client code should <b>not</b> depend on the order in which properties are returned, because that order varies.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with properties. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ae36bf9d997fb8153cdd718e2625f9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1property.html">property</a> rttr::type::get_global_property </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a global property with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no property with the name <code>name</code>, then an invalid property is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A property with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abb7e4653e333b5dfdeaa9b9383d954b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html#aa51c17659f86333038379c23b03d2db0">type_id</a> rttr::type::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the id of this type. </p>
<dl class="section note"><dt>Note</dt><dd>This id is unique at process runtime, but the id can be changed every time the process is executed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type id. </dd></dl>

</div>
</div>
<a class="anchor" id="a825f853dc03724ff3257a194f05070d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the meta data for the given key <code>key</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no meta data is registered with the given <code>key</code>, an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object is returned (see <a class="el" href="classrttr_1_1variant.html#a58930eb7270f8c4824864799ede4f668">variant::is_valid</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object, containing arbitrary data. </dd></dl>

</div>
</div>
<a class="anchor" id="a175fdface61f5d9f04c03ffa06608237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_method </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a method with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a32baf74274a3bc95828843bd52e7d854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1method.html">method</a> rttr::type::get_method </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classrttr_1_1type.html">type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a method with the name <code>name</code> which match the given parameter list <code>params</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no method with the name <code>name</code> and matching parameter list <code>params</code>, then an invalid method is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A method with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afcf9a2bdf56f37bd5ac31e054a1e20c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrttr_1_1method.html">method</a>&gt; rttr::type::get_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all registered methods for this type and all its base classes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The methods are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with method objects </dd></dl>

</div>
</div>
<a class="anchor" id="a260f13a9434bf60c5dd3fa239f5890b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rttr::type::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unique and human-readable name of the type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The content of this string is compiler depended.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type name. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d1e7359ac93bdf53b2e20adf827d3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrttr_1_1property.html">property</a>&gt; rttr::type::get_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all registered properties for this type and all its base classes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The properties are sorted after its order of registration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with properties. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5947a5453ddfd7288445d1035d708b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1property.html">property</a> rttr::type::get_property </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a property with the name <code>name</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When there exists no property with the name <code>name</code>, then an invalid property is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A property with name <code>name</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afa8a46f8ec98eb9ec928bc18591c6b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_property_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the property value of property named <code>name</code> from the instance <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the given instance is empty, the value of global property will be tryed to returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant containing the value of the property. </dd></dl>

</div>
</div>
<a class="anchor" id="a480c12eb9ef23f62b848afce39cd9e17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::get_property_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property value of property named <code>name</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A variant containing the value of the property. </dd></dl>

</div>
</div>
<a class="anchor" id="aefc5cad32ed059496b31c9f764b4cb0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_raw_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a type object which represent the raw type. </p>
<p>A raw type, is a type type without any qualifiers (const and volatile) nor any pointer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When the current type is already the raw type, it will return an copy from itself.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding raw type object. </dd></dl>

</div>
</div>
<a class="anchor" id="a401c0dd60d4cc484f6f80cd44e529979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t rttr::type::get_sizeof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size in bytes of the object representation of the current type (i.e. </p>
<p><code>sizeof(T)</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the type in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="adf5d699f5e6d4a860f83b5a3f2745ddc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classrttr_1_1type.html">type</a>&gt; rttr::type::get_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all registered type objects. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the type object is unspecified.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of type objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a0935035914ebe4ed4e37f6b7a6846cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::type::get_wrapped_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a type object which represent the wrapped type. </p>
<p>A wrapper type is a class which encapsulate an instance of another type. This encapsulate type is also called <em>wrapped type</em>.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><a class="code" href="classrttr_1_1type.html#a74865ba400ab02d7f397ee7cf819df32">type</a> wrapped_type = type::get&lt;std::shared_ptr&lt;int&gt;&gt;().<a class="code" href="classrttr_1_1type.html#a0935035914ebe4ed4e37f6b7a6846cc7">get_wrapped_type</a>(); </div>
<div class="line">wrapped_type == type::get&lt;int*&gt;(); <span class="comment">// yields to true</span></div>
<div class="line"></div>
<div class="line">wrapped_type = type::get&lt;std::reference_wrapper&lt;int&gt;&gt;().<a class="code" href="classrttr_1_1type.html#a0935035914ebe4ed4e37f6b7a6846cc7">get_wrapped_type</a>(); </div>
<div class="line">wrapped_type == type::get&lt;int&gt;(); <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>When the current type is not a wrapper type, this function will return an <a class="el" href="classrttr_1_1type.html#a26ca3f29b201c49b744ab9f6b887471e">invalid type</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>wrapper_mapper&lt;T&gt;</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type object of the wrapped type. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8df07012568973ca0a4c005a5af5dba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::invoke </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>, or as shortcut use simply <code>{}</code>. Methods with registered <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> will be honored.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object containing the possible return value, otherwise when it is a void function an empty but valid variant object. </dd></dl>

</div>
</div>
<a class="anchor" id="a784a38776994799b5352754443781f99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrttr_1_1variant.html">variant</a> rttr::type::invoke </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a global method named <code>name</code> with the specified argument <code>args</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A variant object containing the possible return value, otherwise when it is a void function an empty but valid variant object. Methods with registered <a class="el" href="namespacerttr.html#afdaed4515c436b34b8e24af714a09c64">default_arguments</a> will be honored. </dd></dl>

</div>
</div>
<a class="anchor" id="aac02f948da52aab53c0b52d81685881e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_arithmetic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an arithmetic type. </p>
<p>An arithmetic type is a integral type or a floating point type. e.g. <code>bool</code>, <code>int</code>, <code>float</code>, etc...</p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a arithmetic type, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a42461eee870c91e6b183610f2f24f700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an array. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an array, otherwise false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1array__mapper.html">array_mapper&lt;T&gt;</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a30f0af6a51c3d6096ea445288caacfce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type is class; that is not an atomic type or a method. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a class, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a4142afe939a1c28047b3aa7eb61ed0da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_derived_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this type is derived from the given type <code>other</code>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a derived type from <code>other</code>, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a766405230daf54ea17c261cf1a5a31b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_derived_from </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this type is derived from the given type <em>T</em>, otherwise false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Make sure that the complete class hierarchy has the macro RTTR_ENABLE inside the class declaration, otherwise the returned information of this function is <b>not correct</b>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this type is a derived type from <em>T</em>, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a35926cc4f93039e967eadf36107f3855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_enumeration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents an enumeration. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an enumeration, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a34d52aa9d36a4ca87426ba8f0a767f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_function_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a function e.g. </p>
<p><code>void (*)(void)</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a function pointer, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="afb157054ff6cc035362ddb48fce72497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_member_function_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a member function. </p>
<p>e.g. <code>void (MyClass::*)(void)</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a member function pointer type, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a551a5b2e5f019476812608abd6af777d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_member_object_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer to a member object. </p>
<p>e.g. <code>int (MyClass::*)</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a member object pointer, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ae31c9ee6ca22898a8853dfde804a3bc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a pointer. </p>
<p>e.g. <code>int*</code>, or <code>bool*</code></p>
<dl class="section return"><dt>Returns</dt><dd>True if the type is a pointer, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a26ca3f29b201c49b744ab9f6b887471e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this type is valid, that means the type holds valid data to a type. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is valid, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a395600fecd4a773b3ae1064b3391d556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::is_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true whether the given type represents a wrapper type. </p>
<p>A wrapper type is a class which encapsulate an instance of another type. RTTR recognize automatically following wrapper types:</p><ul>
<li><code><code>std::shared_ptr&lt;T&gt;</code></code> </li>
<li><code><code>std::reference_wrapper&lt;T&gt;</code></code> </li>
<li><code><code>std::weak_ptr&lt;T&gt;</code></code> </li>
<li><code><code>std::unique_ptr&lt;T&gt;</code></code> </li>
</ul>
<p>In order to work with custom wrapper types, its required to specialize the class <a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a> and implement a getter function to retrieve the encapsulate type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrttr_1_1wrapper__mapper.html">wrapper_mapper&lt;T&gt;</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the type is an wrapper, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a7036ca04498a80781f524d94910922d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rttr::type::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to check if this <a class="el" href="classrttr_1_1type.html">type</a> is valid or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this <a class="el" href="classrttr_1_1type.html">type</a> is valid, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a988c18304bc7e14a4e6ccff4b3ee764d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this type with the <em>other</em> type and returns true if both describe different types, otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both type are <b>not</b> equal, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f449e42eba11f2201ed2c12ba2be8e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is less than the <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a39064267f8bc64695053e70fc5742ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is less than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="aef57d6c4fe2940fc8f5218d27dab8ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a>&amp; rttr::type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a type to another one. </p>
<dl class="section return"><dt>Returns</dt><dd>A type object. </dd></dl>

</div>
</div>
<a class="anchor" id="af22a16e1984a7b7874bfe588c68c1db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this type with the <em>other</em> type and returns true if both describe the same type, otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both type are equal, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a615b3b385f10580ba12250ec9e407e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is greater than the <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c60996f2aa6260d9eba48b8a6834039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for sorting the type data according to some internal criterion. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this type is greater than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4912d4dac773276a6142a70a40ab0543"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_comparators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register comparison operators for template type <code>T</code>. </p>
<p>This requires a valid <code>operator==</code> and <code>operator&lt;</code> for type <code>T</code>.</p>
<p>The registered comparison operators will be used in the <a class="el" href="classrttr_1_1variant.html">variant</a> class.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="comment">// two variants, same content</span></div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> a = std::make_tuple&lt;int, std::string&gt;(12, std::string(<span class="stringliteral">&quot;some text&quot;</span>));</div>
<div class="line"> <a class="code" href="classrttr_1_1type.html#ad4f13d06475a06f860c63bc68d0c8a4b">variant</a> b = std::make_tuple&lt;int, std::string&gt;(12, std::string(<span class="stringliteral">&quot;some text&quot;</span>));</div>
<div class="line"></div>
<div class="line"> a == b;                <span class="comment">// yields to false</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// register comparators for template type &#39;&lt;std::tuple&lt;std::string, int&gt;&#39;</span></div>
<div class="line"> type::register_comparators&lt;std::tuple&lt;std::string, int&gt;&gt;();</div>
<div class="line"></div>
<div class="line"> a == b;                <span class="comment">// yields to true</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a8f53d339662e1d961b7def74cc3f47cb" title="Compares this variant with other and returns true if they are equal; otherwise returns false...">variant::operator==()</a>, <a class="el" href="classrttr_1_1variant.html#a95e5d6b969f3708e8708929c34cb933f" title="Compares this variant with other and returns true if this is less than other, otherwise returns false...">variant::operator&lt;()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a81f5f2ea31cc79846a829aa5737680f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rttr::type::register_converter_func </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a converter func <code>F</code>, which will be used internally by the <a class="el" href="classrttr_1_1variant.html">variant</a> class to convert between types. </p>
<p>This function converts a <em>source</em> type to a <em>target</em> type. The signature of this function has to be the following: <code>TargetType (SourceType, bool&amp; ok)</code></p>
<p>See following example code: </p><div class="fragment"><div class="line">std::string conv_func(<span class="keywordtype">int</span> value, <span class="keywordtype">bool</span>&amp; ok)</div>
<div class="line">{</div>
<div class="line">   std::string result = std::to_string(value);</div>
<div class="line">   ok = <span class="keyword">true</span>;</div>
<div class="line">   <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// register the conversion function</span></div>
<div class="line"><a class="code" href="classrttr_1_1type.html#a81f5f2ea31cc79846a829aa5737680f0">type::register_converter_func</a>(conv_func);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1variant.html#a48031e0f0a64cc87b7476138071e9c2c" title="Converts the containing variant internally to the given type target_type. ">variant::convert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a84005c7450f740c8b191ffdd7ea469db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::type::set_property_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set the given value <code>arg</code> to a property named <code>name</code> to the instance <code>obj</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the given instance is empty, the value of a global property with name <code>name</code> will be tryed to set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bool value, which is true, when the value could be set, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ec6614b4bfadc10d05f6ac5a1f62fe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool rttr::type::set_property_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will set the given value <code>arg</code> to a property named <code>name</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A bool value, which is true, when the value could be set, otherwise false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a74abb6f591469f3735a1086764f3f8af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target_Type , typename Source_Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Target_Type rttr_cast </td>
          <td>(</td>
          <td class="paramtype">Source_Type&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the given <code>object</code> of type <code>Source_Type</code> to an object of type <code>Target_Type</code>. </p>
<p>When the given the given <code>object</code> is an instance of type <code>Target_Type</code>, then this function will cast the pointer to the <code>TargetType</code>; otherwise it will return a <code>nullptr</code>. If <code>object</code> is already a <code>nullptr</code> then it will also return a <code>nullptr</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Both class types must contain the macro <a class="el" href="rttr__enable_8h.html#a848bcae21d3a54e07ca6450689820a59">RTTR_ENABLE</a> in the class declaration. <code>Source_Type</code> and <code>Target_Type</code> must be both pointer types.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer of type <code>Target_Type</code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Dec 23 2015 16:15:10 for rttr - 0.9.5 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
