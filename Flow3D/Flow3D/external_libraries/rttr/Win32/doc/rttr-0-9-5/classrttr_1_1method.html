<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.10"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: rttr::method Class Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.5</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>RTTR</span></a></li>
      <li><a href="pages.html"><span>Tutorial</span></a></li>
      <li><a href="pages.html"><span>Installation</span></a></li>
      <li><a href="pages.html"><span>License</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerttr.html">rttr</a></li><li class="navelem"><a class="el" href="classrttr_1_1method.html">method</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrttr_1_1method-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rttr::method Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classrttr_1_1method.html">method</a> class provides several meta information about a method and can be invoked.  
 <a href="classrttr_1_1method.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="method_8h_source.html">method.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0eab23c9268475bb310d282cc1c83d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a0eab23c9268475bb310d282cc1c83d1b">get_access_level</a> () const </td></tr>
<tr class="memdesc:a0eab23c9268475bb310d282cc1c83d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the access level with which this method was <a class="el" href="classrttr_1_1registration_1_1class__.html#ac5da7b9f593ce74ba2abc43646379332">registered</a>.  <a href="#a0eab23c9268475bb310d282cc1c83d1b">More...</a><br /></td></tr>
<tr class="separator:a0eab23c9268475bb310d282cc1c83d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e3a5e2dff32d6cd1645c50b1ab2a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a37e3a5e2dff32d6cd1645c50b1ab2a4b">get_declaring_type</a> () const </td></tr>
<tr class="memdesc:a37e3a5e2dff32d6cd1645c50b1ab2a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class that declares this method.  <a href="#a37e3a5e2dff32d6cd1645c50b1ab2a4b">More...</a><br /></td></tr>
<tr class="separator:a37e3a5e2dff32d6cd1645c50b1ab2a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400f111e3fe250dc33291287e06d46e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a400f111e3fe250dc33291287e06d46e0">get_metadata</a> (const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;key) const </td></tr>
<tr class="memdesc:a400f111e3fe250dc33291287e06d46e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta data for the given key <code>key</code>.  <a href="#a400f111e3fe250dc33291287e06d46e0">More...</a><br /></td></tr>
<tr class="separator:a400f111e3fe250dc33291287e06d46e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4c9b0577a17776b5cd5658d19376de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a7c4c9b0577a17776b5cd5658d19376de">get_name</a> () const </td></tr>
<tr class="memdesc:a7c4c9b0577a17776b5cd5658d19376de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this method.  <a href="#a7c4c9b0577a17776b5cd5658d19376de">More...</a><br /></td></tr>
<tr class="separator:a7c4c9b0577a17776b5cd5658d19376de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cda78e23a59318f9f4df32f93dc6d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a64cda78e23a59318f9f4df32f93dc6d7">get_parameter_infos</a> () const </td></tr>
<tr class="memdesc:a64cda78e23a59318f9f4df32f93dc6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ordered list of <a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> objects, which matches the signature of the method.  <a href="#a64cda78e23a59318f9f4df32f93dc6d7">More...</a><br /></td></tr>
<tr class="separator:a64cda78e23a59318f9f4df32f93dc6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9476a917ba55eb08c8bb4ad9615d34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1type.html">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#af9476a917ba55eb08c8bb4ad9615d34f">get_return_type</a> () const </td></tr>
<tr class="memdesc:af9476a917ba55eb08c8bb4ad9615d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type object of the return type.  <a href="#af9476a917ba55eb08c8bb4ad9615d34f">More...</a><br /></td></tr>
<tr class="separator:af9476a917ba55eb08c8bb4ad9615d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3cae3e83af6865461dd0b7bedd200a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a7b3cae3e83af6865461dd0b7bedd200a">get_signature</a> () const </td></tr>
<tr class="memdesc:a7b3cae3e83af6865461dd0b7bedd200a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the signature of this method as readable string.  <a href="#a7b3cae3e83af6865461dd0b7bedd200a">More...</a><br /></td></tr>
<tr class="separator:a7b3cae3e83af6865461dd0b7bedd200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc77e117f775e336dcefbcb22e444d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object) const </td></tr>
<tr class="memdesc:abfc77e117f775e336dcefbcb22e444d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>.  <a href="#abfc77e117f775e336dcefbcb22e444d3">More...</a><br /></td></tr>
<tr class="separator:abfc77e117f775e336dcefbcb22e444d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d09db2588c495d99ad57c58d99f5f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#ac2d09db2588c495d99ad57c58d99f5f0">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1) const </td></tr>
<tr class="memdesc:ac2d09db2588c495d99ad57c58d99f5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="#ac2d09db2588c495d99ad57c58d99f5f0">More...</a><br /></td></tr>
<tr class="separator:ac2d09db2588c495d99ad57c58d99f5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f45464a6df84254184b6c67fc5e1873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a0f45464a6df84254184b6c67fc5e1873">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2) const </td></tr>
<tr class="memdesc:a0f45464a6df84254184b6c67fc5e1873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="#a0f45464a6df84254184b6c67fc5e1873">More...</a><br /></td></tr>
<tr class="separator:a0f45464a6df84254184b6c67fc5e1873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e49120a76738eb3f7f79989b0ffbc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a3e49120a76738eb3f7f79989b0ffbc90">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3) const </td></tr>
<tr class="memdesc:a3e49120a76738eb3f7f79989b0ffbc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="#a3e49120a76738eb3f7f79989b0ffbc90">More...</a><br /></td></tr>
<tr class="separator:a3e49120a76738eb3f7f79989b0ffbc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d391f14f810569f9363ce502bfad64c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a5d391f14f810569f9363ce502bfad64c">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3, <a class="el" href="classrttr_1_1argument.html">argument</a> arg4) const </td></tr>
<tr class="memdesc:a5d391f14f810569f9363ce502bfad64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="#a5d391f14f810569f9363ce502bfad64c">More...</a><br /></td></tr>
<tr class="separator:a5d391f14f810569f9363ce502bfad64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bbc1d54c9c92870c0a8d285a12f6df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a78bbc1d54c9c92870c0a8d285a12f6df">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3, <a class="el" href="classrttr_1_1argument.html">argument</a> arg4, <a class="el" href="classrttr_1_1argument.html">argument</a> arg5) const </td></tr>
<tr class="memdesc:a78bbc1d54c9c92870c0a8d285a12f6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="#a78bbc1d54c9c92870c0a8d285a12f6df">More...</a><br /></td></tr>
<tr class="separator:a78bbc1d54c9c92870c0a8d285a12f6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad3dcdedf475d4bcf815f9e8ba4782c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#afad3dcdedf475d4bcf815f9e8ba4782c">invoke</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, <a class="el" href="classrttr_1_1argument.html">argument</a> arg1, <a class="el" href="classrttr_1_1argument.html">argument</a> arg2, <a class="el" href="classrttr_1_1argument.html">argument</a> arg3, <a class="el" href="classrttr_1_1argument.html">argument</a> arg4, <a class="el" href="classrttr_1_1argument.html">argument</a> arg5, <a class="el" href="classrttr_1_1argument.html">argument</a> arg6) const </td></tr>
<tr class="memdesc:afad3dcdedf475d4bcf815f9e8ba4782c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="#afad3dcdedf475d4bcf815f9e8ba4782c">More...</a><br /></td></tr>
<tr class="separator:afad3dcdedf475d4bcf815f9e8ba4782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677ac9eae5dd626f43daa45af717d2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrttr_1_1variant.html">variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a677ac9eae5dd626f43daa45af717d2ab">invoke_variadic</a> (<a class="el" href="classrttr_1_1instance.html">instance</a> object, std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt; args) const </td></tr>
<tr class="memdesc:a677ac9eae5dd626f43daa45af717d2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the method represented by the current instance <code>object</code>, using the specified parameters.  <a href="#a677ac9eae5dd626f43daa45af717d2ab">More...</a><br /></td></tr>
<tr class="separator:a677ac9eae5dd626f43daa45af717d2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac4de077ee44688ba50a5f3ff8ca90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a96ac4de077ee44688ba50a5f3ff8ca90">is_static</a> () const </td></tr>
<tr class="memdesc:a96ac4de077ee44688ba50a5f3ff8ca90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is static method, otherwise false.  <a href="#a96ac4de077ee44688ba50a5f3ff8ca90">More...</a><br /></td></tr>
<tr class="separator:a96ac4de077ee44688ba50a5f3ff8ca90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d3f28dc50afc5385cc19af1b19fc45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a00d3f28dc50afc5385cc19af1b19fc45">is_valid</a> () const </td></tr>
<tr class="memdesc:a00d3f28dc50afc5385cc19af1b19fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is valid, otherwise false.  <a href="#a00d3f28dc50afc5385cc19af1b19fc45">More...</a><br /></td></tr>
<tr class="separator:a00d3f28dc50afc5385cc19af1b19fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260976eea4408405dda83e4e84587a16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a260976eea4408405dda83e4e84587a16">operator bool</a> () const </td></tr>
<tr class="memdesc:a260976eea4408405dda83e4e84587a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to check if this method is valid or not.  <a href="#a260976eea4408405dda83e4e84587a16">More...</a><br /></td></tr>
<tr class="separator:a260976eea4408405dda83e4e84587a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3acdca81c65158cac929fdfc4def10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#aaf3acdca81c65158cac929fdfc4def10">operator!=</a> (const <a class="el" href="classrttr_1_1method.html">method</a> &amp;other) const </td></tr>
<tr class="memdesc:aaf3acdca81c65158cac929fdfc4def10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is the not the same like the <code>other</code>.  <a href="#aaf3acdca81c65158cac929fdfc4def10">More...</a><br /></td></tr>
<tr class="separator:aaf3acdca81c65158cac929fdfc4def10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7722249659ad2618a32aeff03bf3b731"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrttr_1_1method.html#a7722249659ad2618a32aeff03bf3b731">operator==</a> (const <a class="el" href="classrttr_1_1method.html">method</a> &amp;other) const </td></tr>
<tr class="memdesc:a7722249659ad2618a32aeff03bf3b731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this method is the same like the <code>other</code>.  <a href="#a7722249659ad2618a32aeff03bf3b731">More...</a><br /></td></tr>
<tr class="separator:a7722249659ad2618a32aeff03bf3b731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classrttr_1_1method.html">method</a> class provides several meta information about a method and can be invoked. </p>
<p>A instance of a method class can only be obtained from the <a class="el" href="classrttr_1_1type.html">type</a> class. See <a class="el" href="classrttr_1_1type.html#a175fdface61f5d9f04c03ffa06608237">type::get_method()</a> and <a class="el" href="classrttr_1_1type.html#afcf9a2bdf56f37bd5ac31e054a1e20c5">type::get_methods()</a>.</p>
<p>For registration a method, nested inside a class, see <a class="el" href="classrttr_1_1registration_1_1class__.html#ac5da7b9f593ce74ba2abc43646379332">registration::class_&lt;T&gt;::method()</a> and for global methods see <a class="el" href="classrttr_1_1registration.html#ab04f8ede05a26a169018c6aa61183199">registration::method()</a>.</p>
<h2>Meta Information </h2>
<p>A <a class="el" href="classrttr_1_1method.html">method</a> has a <a class="el" href="classrttr_1_1method.html#a7c4c9b0577a17776b5cd5658d19376de">name</a>, a <a class="el" href="classrttr_1_1method.html#a7b3cae3e83af6865461dd0b7bedd200a">signature</a>, a <a class="el" href="classrttr_1_1method.html#af9476a917ba55eb08c8bb4ad9615d34f">return type</a>, a list of <a class="el" href="classrttr_1_1method.html#a64cda78e23a59318f9f4df32f93dc6d7">parameter information</a> as well as attributes that specify its behavior: <a class="el" href="classrttr_1_1method.html#a96ac4de077ee44688ba50a5f3ff8ca90">is_static()</a>. When the <a class="el" href="classrttr_1_1method.html">method</a> was declared inside a class, then <a class="el" href="classrttr_1_1method.html#a37e3a5e2dff32d6cd1645c50b1ab2a4b">get_declaring_type()</a> can be used to obtain the type of this class.</p>
<p>The method can be invoked with <a class="el" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke()</a>; When its not a <a class="el" href="classrttr_1_1method.html#a96ac4de077ee44688ba50a5f3ff8ca90">static method</a> you have to provide a valid class instance to invoke the method. This instance can be the raw type on the stack; the current class hierarchy level doesn't matter. It can be also a raw pointer to the object or a <a class="el" href="classrttr_1_1variant.html">variant</a> which contains the instance, again as pointer or stack object. When the method is declared as static you you still have to provide an empty instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>, or as shortcut use simply <code>{}</code>.</p>
<p>A method will be successfully invoked when the provided instance can be converted to the <a class="el" href="classrttr_1_1method.html#a37e3a5e2dff32d6cd1645c50b1ab2a4b">declared class</a> type. When the method has <a class="el" href="classrttr_1_1method.html#a64cda78e23a59318f9f4df32f93dc6d7">parameters</a> defined, then the same number of arguments must be provided and the type itself must 100% match the type of the registered function. An automatically type conversion is <b>not</b> performed.</p>
<p>The return type of <a class="el" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke()</a> is  variant object. This object contains not only the possible return value of a function, it also indicates whether the method was invoked or not. A <a class="el" href="classrttr_1_1variant.html#a58930eb7270f8c4824864799ede4f668">valid</a> variant object means, that then the method was successfully invoked, otherwise not. When the invoked method has no return type, i.e. is a <code>void</code> method, then a valid variant of type <code>void</code> is returned.</p>
<p>While the <a class="el" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke()</a> function can directly forward up to six arguments, it is sometime necessary to forward even more arguments. Therefore the function <a class="el" href="classrttr_1_1method.html#a677ac9eae5dd626f43daa45af717d2ab">invoke_variadic()</a> should be used; it allows to pack an unlimited amount of arguments into a std::vector and forward them to the function.</p>
<p>Another way to invoke a method is to use the <a class="el" href="classrttr_1_1type.html">type</a> class through <a class="el" href="classrttr_1_1type.html#ae8df07012568973ca0a4c005a5af5dba">type::invoke()</a>.</p>
<h2>Copying and Assignment </h2>
<p>A <a class="el" href="classrttr_1_1method.html">method</a> object is lightweight and can be copied by value. However, each copy will refer to the same underlying method.</p>
<h2>Typical Usage </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>MyStruct { <span class="keywordtype">int</span> my_method(<span class="keywordtype">int</span> param) { <span class="keywordflow">return</span> param; } };</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><a class="code" href="classrttr_1_1variant.html">variant</a> obj = <a class="code" href="classrttr_1_1type.html#a7c2252762fa17e4df5151ab122b622c2">type::get_by_name</a>(<span class="stringliteral">&quot;MyStruct&quot;</span>).<a class="code" href="classrttr_1_1type.html#a8c54948eafb21fe494afd1057117f5c1">create</a>({});</div>
<div class="line"><a class="code" href="classrttr_1_1method.html">method</a> func = obj.<a class="code" href="classrttr_1_1variant.html#a9dee5dd153f7867e0a6ab99b9c38ee8d">get_type</a>().<a class="code" href="classrttr_1_1type.html#a175fdface61f5d9f04c03ffa06608237">get_method</a>(<span class="stringliteral">&quot;my_method&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (func)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="classrttr_1_1variant.html">variant</a> val = func.<a class="code" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke</a>(obj, 23);</div>
<div class="line">   std::cout &lt;&lt; val.<a class="code" href="classrttr_1_1variant.html#a363c146e7885661975dfa51fbf92e6e9">get_value</a>&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// prints 23</span></div>
<div class="line">   <span class="comment">// you can also invoke the method with an object on the stack</span></div>
<div class="line">   MyStruct inst;</div>
<div class="line">   val = func.<a class="code" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke</a>(inst, 42);</div>
<div class="line">   std::cout &lt;&lt; val.<a class="code" href="classrttr_1_1variant.html#a363c146e7885661975dfa51fbf92e6e9">get_value</a>&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// prints 42</span></div>
<div class="line">   <span class="comment">// or as pointer</span></div>
<div class="line">   MyStruct* ptr = &amp;inst;</div>
<div class="line">   val = func.<a class="code" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke</a>(ptr, 7);</div>
<div class="line">   std::cout &lt;&lt; val.<a class="code" href="classrttr_1_1variant.html#a363c146e7885661975dfa51fbf92e6e9">get_value</a>&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// prints 7</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrttr_1_1property.html" title="The property class provides several meta information about a property and gives read/write access to ...">property</a>, <a class="el" href="classrttr_1_1enumeration.html" title="The enumeration class provides several meta information about an enum. ">enumeration</a>, <a class="el" href="classrttr_1_1constructor.html" title="The constructor class provides several meta information about a constructor and can be invoked...">constructor</a> and <a class="el" href="classrttr_1_1type.html" title="The type class holds the type information for any arbitrary object. ">type</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0eab23c9268475bb310d282cc1c83d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a> rttr::method::get_access_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the access level with which this method was <a class="el" href="classrttr_1_1registration_1_1class__.html#ac5da7b9f593ce74ba2abc43646379332">registered</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When the method is not valid, this function will return level <a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611ba84807fec67699af41c7bcb3a57dce40b">access_levels::public_access</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacerttr.html#aa07db0e4984d0c48adc5d61f834d611b">access_levels</a> of the method. </dd></dl>

</div>
</div>
<a class="anchor" id="a37e3a5e2dff32d6cd1645c50b1ab2a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::method::get_declaring_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the class that declares this method. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When this method does not belong to a class (i.e. is a global method) it will return an invalid type. When this method is not valid, this function will return an invalid type object (see <a class="el" href="classrttr_1_1type.html#a26ca3f29b201c49b744ab9f6b887471e">type::is_valid</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Type of the underlying property. </dd></dl>

</div>
</div>
<a class="anchor" id="a400f111e3fe250dc33291287e06d46e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::get_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1variant.html">variant</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the meta data for the given key <code>key</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When no meta data is registered with the given <code>key</code>, an invalid <a class="el" href="classrttr_1_1variant.html">variant</a> object is returned (see <a class="el" href="classrttr_1_1variant.html#a58930eb7270f8c4824864799ede4f668">variant::is_valid</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A variant object, containing arbitrary data. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c4c9b0577a17776b5cd5658d19376de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rttr::method::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of this method. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of the method. </dd></dl>

</div>
</div>
<a class="anchor" id="a64cda78e23a59318f9f4df32f93dc6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a>&gt; rttr::method::get_parameter_infos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an ordered list of <a class="el" href="classrttr_1_1parameter__info.html">parameter_info</a> objects, which matches the signature of the method. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of <a class="el" href="classrttr_1_1parameter__info.html" title="The parameter_info class provides several meta information about a parameter. ">parameter_info</a> objects of the method signature. </dd></dl>

</div>
</div>
<a class="anchor" id="af9476a917ba55eb08c8bb4ad9615d34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1type.html">type</a> rttr::method::get_return_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type object of the return type. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3cae3e83af6865461dd0b7bedd200a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string rttr::method::get_signature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the signature of this method as readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>The signature as readable string. </dd></dl>

</div>
</div>
<a class="anchor" id="abfc77e117f775e336dcefbcb22e444d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2d09db2588c495d99ad57c58d99f5f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f45464a6df84254184b6c67fc5e1873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e49120a76738eb3f7f79989b0ffbc90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d391f14f810569f9363ce502bfad64c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="a78bbc1d54c9c92870c0a8d285a12f6df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="afad3dcdedf475d4bcf815f9e8ba4782c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrttr_1_1argument.html">argument</a>&#160;</td>
          <td class="paramname"><em>arg6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="a677ac9eae5dd626f43daa45af717d2ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrttr_1_1variant.html">variant</a> rttr::method::invoke_variadic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrttr_1_1instance.html">instance</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classrttr_1_1argument.html">argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the method represented by the current instance <code>object</code>, using the specified parameters. </p>
<p>Use this method when the argument count is higher then six.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Using this invoke function is slower, then specifying the arguments directly. When it's a static method you still need to provide an instance object, use therefore the default ctor of <a class="el" href="classrttr_1_1instance.html#a5bbe39fd320dc795c8c12a0b2801fdf7">instance()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the return type. </dd></dl>

</div>
</div>
<a class="anchor" id="a96ac4de077ee44688ba50a5f3ff8ca90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::is_static </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this method is static method, otherwise false. </p>
<p>A static method does not need an instance for performing an invoke.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When the method is not valid, this function will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a static method, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a00d3f28dc50afc5385cc19af1b19fc45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this method is valid, otherwise false. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this method is valid, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a260976eea4408405dda83e4e84587a16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rttr::method::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to check if this method is valid or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this method is valid, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf3acdca81c65158cac929fdfc4def10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1method.html">method</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this method is the not the same like the <code>other</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both methods are different, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a7722249659ad2618a32aeff03bf3b731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rttr::method::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrttr_1_1method.html">method</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this method is the same like the <code>other</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if both methods are equal, otherwise false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="method_8h_source.html">method.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Dec 23 2015 16:05:01 for rttr - 0.9.5 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
