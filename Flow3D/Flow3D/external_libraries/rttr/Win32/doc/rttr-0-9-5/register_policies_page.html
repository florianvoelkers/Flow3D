<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.10"/>
        <script type="text/javascript" src="jquery.min.js"></script>
        <title>rttr: Policies</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link rel = "shortcut icon" type = "image/x-icon" href = "favicon.ico">
        <link rel = "stylesheet" href = "fonts/ptsans_regular_macroman/stylesheet.css">
        <link rel = "stylesheet" href = "fonts/source_code_pro_regular/stylesheet.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <link rel="stylesheet" href="custom-bootstrap.css">
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
     <!--
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">rttr 0.9.5</a>
                </div>
            </div>
        </nav>
        -->
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>RTTR</span></a></li>
      <li class="current"><a href="pages.html"><span>Tutorial</span></a></li>
      <li><a href="pages.html"><span>Installation</span></a></li>
      <li><a href="pages.html"><span>License</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Policies </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Sometimes it is necessary to adjust the default registration behaviour of RTTR. Therefore policies were introduced. There are policies for <a class="el" href="structrttr_1_1policy_1_1ctor.html">constructors</a>, <a class="el" href="structrttr_1_1policy_1_1meth.html">methods</a> and <a class="el" href="structrttr_1_1policy_1_1prop.html">properties</a> available.</p>
<p><a class="el" href="register_policies_page.html#ctor_policy_link">Constructors</a>:</p><ul>
<li>as_object</li>
<li>as_std_shared_ptr</li>
<li>as_raw_ptr</li>
</ul>
<p><a class="el" href="register_policies_page.html#prop_policy_link">Properties</a>:</p><ul>
<li>bind_as_ptr</li>
<li>return_ref_as_ptr</li>
</ul>
<p><a class="el" href="register_policies_page.html#meth_policy_link">Methods</a>:</p><ul>
<li>discard_return</li>
</ul>
<p>For easier usage, the policies are grouped to its corresponding items; e.g. all policies for methods can be found under <code>policy::meth</code>; all policies for properties under <code>policy::prop</code> etc.</p>
<h1><a class="anchor" id="ctor_policy_link"></a>
Constructors</h1>
<h3>as_object</h3>
<p>The <a class="el" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">as_object</a> policy will create an instance of a class with automatic storage.</p>
<p>Objects with automatic storage duration are automatically destroyed when the block in which they are created exits. Which is in our case the variant. However, that means also you don't have to deal with pointers or wrappers. In order to use this creation policy, the object must be <em>copy constructible</em>.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1constructor.html">constructor&lt;&gt;</a>()</div>
<div class="line">                   (</div>
<div class="line">                       <a class="code" href="structrttr_1_1policy_1_1ctor.html#a1e3b8ee81a41ce6b2e075bef1620f28c">policy::ctor::as_object</a></div>
<div class="line">                   );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var = type::get&lt;Foo&gt;().create();   <span class="comment">// creates a new instance of &#39;Foo&#39; and moves the content into variant &#39;var&#39;</span></div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#ac29f37430ab46eb9f25554214e9e99dc">is_type</a>&lt;Foo&gt;();           <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var2 = var;                        <span class="comment">// creates a new instance of &#39;Foo&#39;, through copy construction</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;                                  <span class="comment">// the memory of the two &#39;Foo&#39; instances is freed automatically</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>as_std_shared_ptr</h3>
<p>The as_std_shared_ptr policy will create an instance of a class through <em>std::make_shared&lt;T&gt;</em>.</p>
<p>That means the object is wrapped into a <em>std::shared_ptr&lt;T&gt;</em>. The wrapped object is destroyed and its memory deallocated when either of the following happens:</p><ul>
<li>the last remaining variant object (which contains the <em>shared_ptr</em> owning the object is destroyed.</li>
<li>the last remaining variant owning the <em>shared_ptr</em> is assigned another object.</li>
</ul>
<p>The object is destroyed using the default deleter of <em>std::shared_ptr</em>.</p>
<p>See following example code:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1constructor.html">constructor&lt;&gt;</a>()</div>
<div class="line">                   (</div>
<div class="line">                       <a class="code" href="structrttr_1_1policy_1_1ctor.html#a40f2a2ef8f270cad3deabf1b83e8764c">policy::ctor::as_std_shared_ptr</a></div>
<div class="line">                   );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var = type::get&lt;Foo&gt;().create();</div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#ac29f37430ab46eb9f25554214e9e99dc">is_type</a>&lt;std::shared_ptr&lt;Foo&gt;&gt;();  <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;                                          <span class="comment">// the memory for contained &#39;Foo&#39; instance is freed automatically,</span></div>
<div class="line">}                                                    <span class="comment">// because the var object is gone out of scope</span></div>
</div><!-- fragment --><h3>as_raw_ptr</h3>
<p>The as_raw_ptr policy will create an instance of a class as raw pointer.</p>
<p>That means the object is created with a <em>new</em>-expression and its lifetime lasts until it is destroyed using a <em>delete</em>-expression. In order to invoke the delete expression use the corresponding destructor.</p>
<p>See following example code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">     <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                  .<a class="code" href="classrttr_1_1constructor.html">constructor&lt;&gt;</a>()</div>
<div class="line">                  (</div>
<div class="line">                      <a class="code" href="structrttr_1_1policy_1_1ctor.html#a3a8150de98f16fdad329b85f43d32da1">policy::ctor::as_raw_ptr</a></div>
<div class="line">                  );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classrttr_1_1variant.html">variant</a> var = type::get&lt;Foo&gt;().create();</div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#ac29f37430ab46eb9f25554214e9e99dc">is_type</a>&lt;Foo*&gt;();          <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">  var.<a class="code" href="classrttr_1_1variant.html#a9dee5dd153f7867e0a6ab99b9c38ee8d">get_type</a>().<a class="code" href="classrttr_1_1type.html#a73823b1d1e4158329a341650aa151ef5">destroy</a>(var);               <span class="comment">// free&#39;s the memory with &#39;delete&#39;</span></div>
<div class="line">  std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#a58930eb7270f8c4824864799ede4f668">is_valid</a>();               <span class="comment">// prints &quot;false&quot;</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="prop_policy_link"></a>
Properties</h1>
<h3>bind_as_ptr</h3>
<p>The motivation for this policy is to avoid expensive copies when returning a property. The default registration behaviour of RTTR is to return all values by copying the content in a variant. When you have primitive data types like integer or doubles you are good to go with the standard binding behaviour. But when you have big arrays, it would be a waste to always copy the content when retrieving or setting the value, therefore this policy was introduced.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;int&gt; vec;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                 .<a class="code" href="classrttr_1_1property.html">property</a>(<span class="stringliteral">&quot;vec&quot;</span>, &amp;Foo::vec)</div>
<div class="line">                 (</div>
<div class="line">                     <a class="code" href="structrttr_1_1policy_1_1prop.html#af18a7107143029acd396d39abfd8c94c">policy::prop::bind_as_ptr</a></div>
<div class="line">                 )</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Foo obj;</div>
<div class="line">    <span class="keyword">property</span> prop = type::get&lt;Foo&gt;().get_property(<span class="stringliteral">&quot;vec&quot;</span>);</div>
<div class="line">    <a class="code" href="classrttr_1_1variant.html">variant</a> var = prop.<a class="code" href="classrttr_1_1variant.html#a363c146e7885661975dfa51fbf92e6e9">get_value</a>(obj);</div>
<div class="line">    std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#ac29f37430ab46eb9f25554214e9e99dc">is_type</a>&lt;std::vector&lt;int&gt;*&gt;(); <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// not really necessary, but remark that now a std::vector&lt;int&gt;* is expected</span></div>
<div class="line">    prop.set_value(obj, var);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>return_ref_as_ptr</h3>
<p>The motivation for this policy is the same like the bind_property_as_ptr policy. When you really need to get a reference to the return value of a method call you have to use this policy, otherwise the returned reference will be copied into the variant.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::string&amp; get_text() { <span class="keyword">static</span> std::string text; <span class="keywordflow">return</span> text; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                 .<a class="code" href="classrttr_1_1method.html">method</a>(<span class="stringliteral">&quot;get_text&quot;</span>, &amp;Foo::get_text)</div>
<div class="line">                 (</div>
<div class="line">                     <a class="code" href="structrttr_1_1policy_1_1meth.html#ad67ab6cccd0eefa54b80a83851105018">policy::meth::return_ref_as_ptr</a></div>
<div class="line">                 );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Foo obj;</div>
<div class="line">    <a class="code" href="classrttr_1_1method.html">method</a> meth  = type::get&lt;Foo&gt;().get_method(<span class="stringliteral">&quot;get_text&quot;</span>);</div>
<div class="line">    <a class="code" href="classrttr_1_1variant.html">variant</a> var = meth.<a class="code" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke</a>(obj);</div>
<div class="line">    std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#ac29f37430ab46eb9f25554214e9e99dc">is_type</a>&lt;std::string*&gt;(); <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="meth_policy_link"></a>
Methods</h1>
<h3>discard_return</h3>
<p>Sometimes it is necessary that the client caller should ignore the return value of a method call. Therefore this policies was introduced.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> calculate_func() { <span class="keywordflow">return</span> 42; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="registration_8h.html#ac6326400f16225ee15b52eabcaae8130">RTTR_REGISTRATION</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacerttr.html">rttr</a>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classrttr_1_1registration_1_1class__.html">registration::class_&lt;Foo&gt;</a>(<span class="stringliteral">&quot;Foo&quot;</span>)</div>
<div class="line">                 .<a class="code" href="classrttr_1_1method.html">method</a>(<span class="stringliteral">&quot;get_value&quot;</span>, &amp;Foo::calculate_func)</div>
<div class="line">                 (</div>
<div class="line">                     <a class="code" href="structrttr_1_1policy_1_1meth.html#a1797eaaddcd48aa0de8edd79ea9070f9">policy::meth::discard_return</a></div>
<div class="line">                 );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Foo obj;</div>
<div class="line">    <a class="code" href="classrttr_1_1method.html">method</a> meth  = type::get&lt;Foo&gt;().get_method(<span class="stringliteral">&quot;calculate_func&quot;</span>);</div>
<div class="line">    <a class="code" href="classrttr_1_1variant.html">variant</a> var = meth.<a class="code" href="classrttr_1_1method.html#abfc77e117f775e336dcefbcb22e444d3">invoke</a>(obj);</div>
<div class="line">    std::cout &lt;&lt; var.<a class="code" href="classrttr_1_1variant.html#ac29f37430ab46eb9f25554214e9e99dc">is_type</a>&lt;<span class="keywordtype">void</span>&gt;(); <span class="comment">// prints &quot;true&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>A closing hint: you can of course build your own policies in that way, that you build wrappers around your properties or methods and then bind the wrapper instead of the original accessor.</p>
<hr/>
<div type="button" class="btn btn-default doxy-button"><a class="el" href="parameter_names_page.html">previous</a></div><div class="btn btn-default doxy-button"><a class="el" href="tutorial_page.html">Finished</a></div> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
Generated on Wed Dec 23 2015 16:05:01 for rttr - 0.9.5 by 
<a href="http://www.doxygen.org/index.html">doxygen</a>.
</small>
</address>
</body>
</html>
